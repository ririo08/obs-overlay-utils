import{t as $,c as P,h as j}from"./g_WTuoZB.js";import{a9 as B,aa as x,ab as F,ac as S,ad as z,ae as H,R as U,af as b,r as q,ag as L,D as N,ah as V,A as I,ai as M,aj as K,h as Q,B as k,ak as G,g as W,q as _,al as Y,am as J}from"./B2Wlo6SW.js";const E=new WeakMap;function ie(t,r,s={}){const{mode:c="replace",route:a=B(),router:e=x(),transform:i}=s,D=i&&"get"in i?i.get:i??(f=>f),w=i&&"set"in i?i.set:f=>f;E.has(e)||E.set(e,new Map);const h=E.get(e);let y=a.query[t];$(()=>{y=void 0});let n;const v=F((f,g)=>(n=g,{get(){return f(),D(y!==void 0?y:P(r))},set(d){d=w(d),y!==d&&(y=d===P(r)||d===null?void 0:d,h.set(t,d===P(r)||d===null?void 0:d),g(),z(()=>{if(h.size===0)return;const u=Object.fromEntries(h.entries());h.clear();const{params:m,query:l,hash:o}=a;e[P(c)]({params:m,query:{...l,...u},hash:o})}))}}));return S(()=>a.query[t],f=>{y!==D(f)&&(y=f,n())},{flush:"sync"}),v}const ce=()=>H("color-mode").value,X=t=>t==="defer"||t===!1;function Z(...t){var d;const r=typeof t[t.length-1]=="string"?t.pop():void 0;typeof t[0]!="string"&&t.unshift(r);let[s,c,a={}]=t;if(typeof s!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof c!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const e=U(),i=c,D=()=>b.value,w=()=>e.isHydrating?e.payload.data[s]:e.static.data[s];a.server=a.server??!0,a.default=a.default??D,a.getCachedData=a.getCachedData??w,a.lazy=a.lazy??!1,a.immediate=a.immediate??!0,a.deep=a.deep??b.deep,a.dedupe=a.dedupe??"cancel";const h=a.getCachedData(s,e),y=h!=null;if(!e._asyncData[s]||!a.immediate){(d=e.payload._errors)[s]??(d[s]=b.errorValue);const u=a.deep?q:L;e._asyncData[s]={data:u(y?h:a.default()),pending:q(!y),error:N(e.payload._errors,s),status:q("idle"),_default:a.default}}const n={...e._asyncData[s]};delete n._default,n.refresh=n.execute=(u={})=>{if(e._asyncDataPromises[s]){if(X(u.dedupe??a.dedupe))return e._asyncDataPromises[s];e._asyncDataPromises[s].cancelled=!0}if(u._initial||e.isHydrating&&u._initial!==!1){const l=u._initial?h:a.getCachedData(s,e);if(l!=null)return Promise.resolve(l)}n.pending.value=!0,n.status.value="pending";const m=new Promise((l,o)=>{try{l(i(e))}catch(C){o(C)}}).then(async l=>{if(m.cancelled)return e._asyncDataPromises[s];let o=l;a.transform&&(o=await a.transform(l)),a.pick&&(o=ee(o,a.pick)),e.payload.data[s]=o,n.data.value=o,n.error.value=b.errorValue,n.status.value="success"}).catch(l=>{if(m.cancelled)return e._asyncDataPromises[s];n.error.value=K(l),n.data.value=Q(a.default()),n.status.value="error"}).finally(()=>{m.cancelled||(n.pending.value=!1,delete e._asyncDataPromises[s])});return e._asyncDataPromises[s]=m,e._asyncDataPromises[s]},n.clear=()=>A(e,s);const v=()=>n.refresh({_initial:!0}),f=a.server!==!1&&e.payload.serverRendered;{const u=k();if(u&&f&&a.immediate&&!u.sp&&(u.sp=[]),u&&!u._nuxtOnBeforeMountCbs){u._nuxtOnBeforeMountCbs=[];const o=u._nuxtOnBeforeMountCbs;V(()=>{o.forEach(C=>{C()}),o.splice(0,o.length)}),I(()=>o.splice(0,o.length))}f&&e.isHydrating&&(n.error.value||h!=null)?(n.pending.value=!1,n.status.value=n.error.value?"error":"success"):u&&(e.payload.serverRendered&&e.isHydrating||a.lazy)&&a.immediate?u._nuxtOnBeforeMountCbs.push(v):a.immediate&&v();const m=G();if(a.watch){const o=S(a.watch,()=>n.refresh());m&&M(o)}const l=e.hook("app:data:refresh",async o=>{(!o||o.includes(s))&&await n.refresh()});m&&M(l)}const g=Promise.resolve(e._asyncDataPromises[s]).then(()=>n);return Object.assign(g,n),g}function A(t,r){r in t.payload.data&&(t.payload.data[r]=void 0),r in t.payload._errors&&(t.payload._errors[r]=b.errorValue),t._asyncData[r]&&(t._asyncData[r].data.value=void 0,t._asyncData[r].error.value=b.errorValue,t._asyncData[r].pending.value=!1,t._asyncData[r].status.value="idle"),r in t._asyncDataPromises&&(t._asyncDataPromises[r]&&(t._asyncDataPromises[r].cancelled=!0),t._asyncDataPromises[r]=void 0)}function ee(t,r){const s={};for(const c of r)s[c]=t[c];return s}function ae(t,r,s){const[c={},a]=[{},r],e=W(()=>_(t)),i=c.key||j([a,typeof e.value=="string"?e.value:"",...te(c)]);if(!i||typeof i!="string")throw new TypeError("[nuxt] [useFetch] key must be a string: "+i);if(!t)throw new Error("[nuxt] [useFetch] request is missing.");const D=i===a?"$f"+i:i;if(!c.baseURL&&typeof e.value=="string"&&e.value[0]==="/"&&e.value[1]==="/")throw new Error('[nuxt] [useFetch] the request URL must not start with "//".');const{server:w,lazy:h,default:y,transform:n,pick:v,watch:f,immediate:g,getCachedData:d,deep:u,dedupe:m,...l}=c,o=Y({...J,...l,cache:typeof c.cache=="boolean"?void 0:c.cache}),C={server:w,lazy:h,default:y,transform:n,pick:v,immediate:g,getCachedData:d,deep:u,dedupe:m,watch:f===!1?[]:[o,e,...f||[]]};let p;return Z(D,()=>{var T;(T=p==null?void 0:p.abort)==null||T.call(p,new DOMException("Request aborted as another request to the same endpoint was initiated.","AbortError")),p=typeof AbortController<"u"?new AbortController:{};const R=_(c.timeout);let O;return R&&(O=setTimeout(()=>p.abort(new DOMException("Request aborted due to timeout.","AbortError")),R),p.signal.onabort=()=>clearTimeout(O)),(c.$fetch||globalThis.$fetch)(e.value,{signal:p.signal,...o}).finally(()=>{clearTimeout(O)})},C)}function te(t){var s;const r=[((s=_(t.method))==null?void 0:s.toUpperCase())||"GET",_(t.baseURL)];for(const c of[t.params||t.query]){const a=_(c);if(!a)continue;const e={};for(const[i,D]of Object.entries(a))e[_(i)]=_(D);r.push(e)}return r}const ue=async(t,r)=>{var c,a,e;const s=await ae(`https://www.googleapis.com/youtube/v3/channels?id=${r}&key=${t}&part=statistics`,"$eyTubiREEH");if((c=s.data.value)!=null&&c.items&&(a=s.data.value.items[0].statistics)!=null&&a.subscriberCount){const i=parseInt((e=s.data.value.items[0].statistics)==null?void 0:e.subscriberCount);return isNaN(i)?0:i}return 0};export{ie as a,ue as g,ce as u};
